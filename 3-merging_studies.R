source('functions.R')
library(doParallel)

# ATTENTION: reproducing these results might take several days depending on the computational infrastructure.

table <- read.csv('output/degree_distr_singleStudy_HIPPIEunionIntact2022_ninter_2_noNA_10.csv')
hippie_intact <- read.csv('databases/HIPPIE_union_Intact2022_afterReviewed_mapping.csv')
npl_studies <- table$pubmedID[which(table$pvalue < 0.1)]
length(npl_studies) # 441

#--------------------------------------------------------------------------------
# merge randomly non-PL studies
#--------------------------------------------------------------------------------

dir_out <- 'output/'
nstudy <- c(100,200,300)

n <- 1000
#n <- 2
tr <- 2
network <- hippie_intact

cl <- makeCluster(10, outfile="out.log")
registerDoParallel(cl)

for(j in nstudy){
  print(j)
  f <- foreach(i = seq(1,n),.combine=rbind) %dopar%{
    source('functions.R')
    set.seed(i)
    print(i)
    studies <- sample(npl_studies, j, replace = F, prob = NULL)
    print(sort(studies))
    network_studies <- network[which(network$Publication_Identifiers %in% studies),]
    n_protein <- length(union(network_studies$IDs_interactor_A,network_studies$IDs_interactor_B))

    #calculate the number of interactions
    d_index <- index_edges_duplicates(network_studies[,c('IDs_interactor_A','IDs_interactor_B')])
    #eliminate bidirectional edges
    if(length(d_index) > 0){
      r <- network_studies[-d_index,]
    }

    g <- unique(network_studies[,c('IDs_interactor_A','IDs_interactor_B')])
    degree <- degree_wo_bidirEdges(g)
    s <- paste0(sort(studies), collapse = ',')
    if(is.na(xmin_estimated(degree$degree))){
      result <- c(NA,nrow(r),n_protein,NA,NA,NA,s)
    }else{
      p <- check_powerLaw(degree$degree, plot = F, t = tr,myseed = i)
      xmin <- xmin_estimated(degree$degree)
      alpha <- alpha_estimated(degree$degree)
      ntail <- length(which(degree$degree >= xmin_estimated(degree$degree)))
      result <- c(p$p,nrow(r),n_protein,xmin,alpha,ntail,s)
    }

  }
  colnames(f) <- c('pvalue','num_inter','n_proteins','xmin','alpha','ntail','pubmedIDs')
  write.csv(f, file = paste0(dir_out,'/table_merge_',j,'NPLstudies_n',n,'degree.csv'),row.names = F)
}
stopCluster(cl)


#-----------------------------------------------------------------
# plot the P-value generated by the previous analysis
#-----------------------------------------------------------------

dir_out <- 'output/'
table_100 <- read.csv(paste0(dir_out,'table_merge_100NPLstudies_n1000degree.csv'))
table_100$nstudy <- rep(100,nrow(table_100))
table_200 <- read.csv(paste0(dir_out,'table_merge_200NPLstudies_n1000degree.csv'))
table_200$nstudy <- rep(200,nrow(table_200))
table_300 <- read.csv(paste0(dir_out,'table_merge_300NPLstudies_n1000degree.csv'))
table_300$nstudy <- rep(300,nrow(table_300))
length(which(table_100$pvalue >= 0.1))
length(which(table_200$pvalue >= 0.1))
length(which(table_300$pvalue >= 0.1))

table <- as.data.frame(rbind(table_100,table_200,table_300))
table$nstudy <- as.factor(table$nstudy)

ggplot(table, aes(x=nstudy, y= pvalue)) +
  geom_boxplot() + xlab('Number of random non-PL studies') + ylab('P-value') + theme_bw() +
  geom_hline(yintercept=0.1, linetype="dashed", color = "red") + theme(axis.text = element_text(size = 10), axis.title = element_text(size = 10)) +
  annotate('text',
           x = 1:length(table(table$nstudy)),
           y = 1.2,
           label = table(table$nstudy[which(table$pvalue >= 0.1)])/1000,
           size = 3.6)
ggsave(paste0('plots/','boxplot_mergingNPL.pdf'),height = 10, width = 10,units = 'cm')


#------------------------------------------------------------------------------------
# merge random non-PL studies (without selecting studies with specific features) 
# and calculate degree and bait distribution (using only studies with bait 
# annotations)
#------------------------------------------------------------------------------------
intact <- read.csv('databases/IntAct_afterFiltering.csv')
intact_bait <- intact[which(intact$Experimental_roles_interactor_A == 'bait' | intact$Experimental_roles_interactor_B == 'bait'),]
studies_bait <- unique(intact_bait$Publication_Identifiers)
length(studies_bait) #7614
length(union(intact_bait$IDs_interactor_A,intact_bait$IDs_interactor_B))
intact_bait <- intact_bait[,c('IDs_interactor_A','IDs_interactor_B', 'Experimental_roles_interactor_A','Experimental_roles_interactor_B','Publication_Identifiers')]
intact_bait <- unique(intact_bait)
network <- intact_bait

intact_degree <- read.csv('output/degree_distr_singleStudy_Intact_ninter_2_noNA_10.csv')
npl_studies <- intact_degree$pubmedID[which(intact_degree$pvalue < 0.1)]
studies_bait <- intersect(studies_bait,npl_studies)
print(length(studies_bait))

nstudy <- c(50,100,150)
n <- 1000
#n <- 2
tr <- 2

cl <- makeCluster(5, outfile="out.log")
registerDoParallel(cl)

for(j in nstudy){
  print(j)
  f <- foreach(i = seq(1,n),.combine=rbind) %dopar%{
    source('functions.R')
    set.seed(i)
    studies <- sample(studies_bait, j, replace = F, prob = NULL)
    network_studies <- network[which(network$Publication_Identifiers %in% studies),]
    n_protein <- length(union(network_studies$IDs_interactor_A,network_studies$IDs_interactor_B))

    #calculate the number of interactions
    d_index <- index_edges_duplicates(network_studies[,c('IDs_interactor_A','IDs_interactor_B')])
    #eliminate bidirectional edges with the same pubmedID
    if(length(d_index) > 0){
      r <- network_studies[-d_index,]
    }
    #calculate bait usage
    baits <- get_bait_prey(network_studies,'bait')
    bait_usage <- calculate_bait_usage(network_studies,baits,'bait')

    g <- unique(network_studies[,c('IDs_interactor_A','IDs_interactor_B')])
    degree <- degree_wo_bidirEdges(g)
    if(is.na(xmin_estimated(degree$degree))){
      print(paste0('Unable to estimate xmin \n'))
      if(is.na(xmin_estimated(as.numeric(bait_usage$bait_usage)))){
        result <- c(NA,NA,nrow(r),n_protein,NA,NA)
      }else{
        b <- check_powerLaw(as.numeric(bait_usage$bait_usage),plot = F, t = tr,myseed = i)
        result <- c(NA,b$p,nrow(r),n_protein,NA,length(which(is.na(b$bootstraps$xmin) == T)))
      }
    }else{
      p <- check_powerLaw(degree$degree, plot = F, t = tr,myseed = i)
      if(is.na(xmin_estimated(as.numeric(bait_usage$bait_usage)))){
        result <- c(p$p,NA,nrow(r),n_protein,length(which(is.na(p$bootstraps$xmin) == T)),NA)
      }else{
        b <- check_powerLaw(as.numeric(bait_usage$bait_usage),plot = F, t = tr,myseed = i)
        result <- c(p$p,b$p,nrow(r),n_protein,length(which(is.na(p$bootstraps$xmin) == T)),length(which(is.na(b$bootstraps$xmin) == T)))
      }
    }
  }
  colnames(f) <- c('pvalue_degree','pvalue_bait','num_inter','n_proteins','n_NA_degree','n_NA_bait')
  dir_out <- 'output'
  write.csv(f, file = paste0(dir_out,'/table_merge_',j,'NPLstudies_n',n,'_degree-bait_Intact2022.csv'),row.names = F)
  
}
stopCluster(cl)

#--------------------------------------------------------------------------------
# fisher test to test the association among degree and bait distributions
#--------------------------------------------------------------------------------

dir_out <- 'output'
n <- 1000
table_50 <- read.csv(paste0(dir_out,'/table_merge_50NPLstudies_n',n,'_degree-bait_Intact2022.csv'))
table_50$n_study <- rep(50,nrow(table_50))
table_100 <- read.csv(paste0(dir_out,'/table_merge_100NPLstudies_n',n,'_degree-bait_Intact2022.csv'))
table_100$n_study <- rep(100,nrow(table_100))
table_150 <- read.csv(paste0(dir_out,'/table_merge_150NPLstudies_n',n,'_degree-bait_Intact2022.csv'))
table_150$n_study <- rep(150,nrow(table_150))

table <- rbind(table_50,table_100,table_150)

bait_degree_pl <- length(which(table$pvalue_degree >= 0.1 & table$pvalue_bait >= 0.1))
bait_pl_degree_npl <- length(which(table$pvalue_degree < 0.1 & table$pvalue_bait >= 0.1))
bait_npl_degree_pl <- length(which(table$pvalue_degree >= 0.1 & table$pvalue_bait < 0.1))
bait_degree_npl <- length(which(table$pvalue_degree < 0.1 & table$pvalue_bait < 0.1))

matrix <- matrix(c(bait_degree_pl,bait_pl_degree_npl,bait_npl_degree_pl,bait_degree_npl), ncol = 2,nrow = 2)
matrix
fisher.test(matrix)
print(fisher.test(matrix, alternative = 'greater'))
